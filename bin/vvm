#!/usr/bin/python

import optparse
import os
import os.path
import shutil
import sys




class VimVersionManager:
  # Directory structure:
  #   ~/.vvm                 The root directory for Vim Version Manager.
  #     bin                  For command-line utilities.
  #     src                  Place to store source code of each version.
  #       ...
  #       $fork--$tagname    Naming is the same as ~/.vvm/vims.
  #     vims                 Place to store deployed versions.
  #       vimorg--v7-3-254   Install directory for the original one.
  #       macvim--v7.3-53    Install directory for MacVim.
  #       ...
  #       $fork--$tagname    This is the "version" format.
  #       current            Symbolic link for an install directory.

  # Driver::

  def main(self, args):
    p = optparse.OptionParser(version='%prog 1.2.3')
    p.disable_interspersed_args()
    (options, left_args) = p.parse_args(args[1:])
    if len(left_args) == 0:
      p.print_help()
    else:
      subcmd_name = left_args[0]
      try:
        subcmd_func = getattr(self, 'cmd_%s' % subcmd_name)
      except AttributeError:
        die('Subcommand "%s" is not available.' % subcmd_name)
      subcmd_func(left_args)
    return

  # Subcommands::

  def cmd_help(self, args):
    # FIXME: Add more useful description.
    '''Show help message to use Vim Version Manager.'''
    subcmd_names = [n for n in dir(self) if n.startswith('cmd_')]
    subcmd_names.sort()
    longest_subcmd_name = max(len(n) for n in subcmd_names)
    print 'Available commands:'
    for n in subcmd_names:
      print '  %s%s%s' % (
        n[len('cmd_'):],
        ' ' * (longest_subcmd_name - len(n) + 2),
        getattr(self, n).__doc__.split('\n')[0]
      )
    return

  def cmd_install(self, args):
    '''Install a specific version of Vim.'''
    p = optparse.OptionParser()
    p.disable_interspersed_args()
    p.usage = '%prog install $version'
    (options, left_args) = p.parse_args(args[1:])
    if len(left_args) == 0:
      die('Please specify a version of Vim to install.')
    version = left_args[0]
    configure_options = left_args[1:]
    self.fetch(version)
    self.checkout(version)
    self.configure(version, configure_options)
    self.make_install(version)
    return

  def cmd_rebuild(self, args):
    '''Rebuild a specific version of Vim, then install it.'''
    p = optparse.OptionParser()
    p.disable_interspersed_args()
    p.usage = '%prog rebuild $version'
    (options, left_args) = p.parse_args(args[1:])
    if len(left_args) == 0:
      die('Please specify a version of Vim to rebuild.')
    version = left_args[0]
    configure_options = left_args[1:]
    self.make_clean(version)
    self.configure(version, configure_options)
    self.make_install(version)
    return

  def cmd_reinstall(self, args):
    '''Reinstall a specific version of Vim.'''
    p = optparse.OptionParser()
    p.disable_interspersed_args()
    p.usage = '%prog reinstall $version'
    (options, left_args) = p.parse_args(args[1:])
    if len(left_args) == 0:
      die('Please specify a version of Vim to reinstall.')
    self.cmd_uninstall(('uninstall',) + tuple(left_args))
    self.cmd_install(('install',) + tuple(left_args))
    return

  def cmd_uninstall(self, args):
    '''Uninstall a specific version of Vim.'''
    p = optparse.OptionParser()
    p.disable_interspersed_args()
    p.usage = '%prog uninstall $version'
    (options, left_args) = p.parse_args(args[1:])
    if len(left_args) == 0:
      die('Please specify a version of Vim to uninstall.')
    version = left_args[0]
    current_path = '~/.vvm/vims/current'
    src_dir = '~/.vvm/src/%s' % version
    vims_dir = '~/.vvm/vims/%s' % version
    if isdir(current_path):
      target_path = readlink(current_path)
      if normalize_path(target_path) == normalize_path(vims_dir):
        die('%s can not be uninstalled; it is currently used.' % version)
    if isdir(src_dir):
      rm_r(src_dir)
    else:
      print 'Something wrong; %s source does not exist.' % version
    if isdir(vims_dir):
      rm_r(vims_dir)
    else:
      print 'Something wrong; %s binary does not exist.' % version
    return

  def cmd_use(self, args):
    '''Use a specific version of Vim as the default one.'''
    p = optparse.OptionParser()
    p.disable_interspersed_args()
    p.usage = '%prog use $version'
    (options, left_args) = p.parse_args(args[1:])
    if len(left_args) == 0:
      die('Please specify a version of Vim to use.')
    version = left_args[0]
    if version == 'system':
      current_path = '~/.vvm/vims/current'
      if isdir(current_path):
        rm(current_path)
    else:
      vims_dir = '~/.vvm/vims/%s' % version
      if not isdir(vims_dir):
        die('%s is not installed.' % version)
      current_path = '~/.vvm/vims/current'
      if isdir(current_path):
        rm(current_path)
      ln_s(vims_dir, current_path)
    return

  # Utilities::

  def checkout(self, version):
    (fork, tagname) = parse_version(version)
    try:
      checkout_func = getattr(self, 'checkout_%s' % fork)
    except AttributeError:
      die('Fork "%s" is not known.' % fork)
    return checkout_func(version, fork, tagname)

  def checkout_vimorg(self, version, fork, tagname):
    if not has('hg'):
      die('Mercurial is required to checkout %s.' % fork)
    src_dir = '~/.vvm/src/%s' % version
    if not isdir(src_dir):
      die('Source code of %s is not fetched.' % version)
    sh('cd %s && hg update %s' % (src_dir, tagname))
    return

  def configure(self, version, custom_configure_options):
    default_configure_options = (
      '"--prefix=$HOME/.vvm/vims/%s"' % version,
    )
    sh('cd %s && ./configure %s' % (
      '~/.vvm/src/%s' % version,
      ' '.join(
        default_configure_options
        + tuple(custom_configure_options)
      )
    ))
    return

  def fetch(self, version):
    (fork, tagname) = parse_version(version)
    try:
      fetch_func = getattr(self, 'fetch_%s' % fork)
    except AttributeError:
      die('Fork "%s" is not known.' % fork)
    return fetch_func(version, fork, tagname)

  def fetch_vimorg(self, version, fork, tagname):
    if not has('hg'):
      die('Mercurial is required to install %s.' % fork)
    mkdir('~/.vvm/src')
    sh('hg clone https://vim.googlecode.com/hg/ ~/.vvm/src/%s' % version)
    return

  def make_clean(self, version):
    make(version, ('clean',))
    return

  def make_install(self, version):
    make(version, ('install',))
    return




def die(message):
  return exit(message)

def has(progname):
  return sh('which %s >/dev/null 2>/dev/null' % progname) == 0

def isdir(path):
  return os.path.isdir(os.path.expanduser(path))

def ln_s(target, link_name):
  return os.symlink(os.path.expanduser(target), os.path.expanduser(link_name))

def make(version, args):
  return sh('cd %s && make %s' % (
    '~/.vvm/src/%s' % version,
    ' '.join(args)
  ))

def mkdir(path):
  return os.makedirs(os.path.expanduser(path), 0755)

def normalize_path(path):
  return os.path.abspath(os.path.expanduser(path))

def parse_version(version):
  return version.split('--')

def readlink(path):
  return os.readlink(os.path.expanduser(path))

def rm(path):
  return os.remove(os.path.expanduser(path))

def rm_r(path):
  return shutil.rmtree(os.path.expanduser(path))

def sh(cmdline):
  return os.system(cmdline)




if __name__ == '__main__':
  VimVersionManager().main(sys.argv)

# __END__
